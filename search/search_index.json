{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HTTPX OAuth","text":"<p> Async OAuth client using HTTPX </p> <p> </p> <p></p> <p> </p> <p>Documentation: https://frankie567.github.io/httpx-oauth/</p> <p>Source Code: https://github.com/frankie567/httpx-oauth</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install httpx-oauth\n</code></pre>"},{"location":"#contributors","title":"Contributors \u2728","text":"<p>Thanks goes to these wonderful people (emoji key):</p> <sub>Fran\u00e7ois Voron</sub>\ud83d\udea7 <sub>Xavi Torell\u00f3</sub>\ud83d\udcbb <sub>dbf</sub>\ud83d\udcbb <sub>Kenton Parton</sub>\ud83d\udcbb <sub>stepan-chatalyan</sub>\ud83d\udcbb <sub>Foster Snowhill</sub>\ud83d\udcbb <sub>William Hatcher</sub>\ud83d\udcbb <sub>Matt Chan</sub>\ud83d\udce6 <sub>Goran Meki\u0107</sub>\ud83d\udce6 <sub>Joona Yoon</sub>\ud83d\udcbb <sub>LindezaGrey</sub>\ud83d\udcbb <sub>R. Singh</sub>\ud83d\udc1b <sub>Lukas L\u00f6sche</sub>\ud83d\udc1b \ud83d\udcbb <sub>James King</sub>\ud83d\udcbb <p>This project follows the all-contributors specification. Contributions of any kind welcome!</p>"},{"location":"#development","title":"Development","text":""},{"location":"#setup-environment","title":"Setup environment","text":"<p>We use Hatch to manage the development environment and production build. Ensure it's installed on your system.</p>"},{"location":"#run-unit-tests","title":"Run unit tests","text":"<p>You can run all the tests with:</p> <pre><code>hatch run test\n</code></pre>"},{"location":"#format-the-code","title":"Format the code","text":"<p>Execute the following command to apply <code>isort</code> and <code>black</code> formatting:</p> <pre><code>hatch run lint\n</code></pre>"},{"location":"#serve-the-documentation","title":"Serve the documentation","text":"<p>You can serve the documentation locally with the following command:</p> <pre><code>hatch run docs\n</code></pre> <p>The documentation will be available on http://localhost:8000.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"fastapi/","title":"FastAPI","text":"<p>Utilities are provided to ease the integration of an OAuth2 process in FastAPI.</p>"},{"location":"fastapi/#oauth2authorizecallback","title":"<code>OAuth2AuthorizeCallback</code>","text":"<p>Dependency callable to handle the authorization callback. It reads the query parameters and returns the access token and the state.</p> <p>Parameters</p> <ul> <li><code>client: OAuth2</code>: The OAuth2 client.</li> <li><code>route_name: Optional[str]</code>: Name of the callback route, as defined in the <code>name</code> parameter of the route decorator.</li> <li><code>redirect_url: Optional[str]</code>: Full URL to the callback route.</li> </ul> <p>Tip</p> <p>You should either set <code>route_name</code>, which will automatically reverse the URL, or <code>redirect_url</code>, which is an arbitrary URL you set.</p> <pre><code>from fastapi import FastAPI, Depends\nfrom httpx_oauth.integrations.fastapi import OAuth2AuthorizeCallback\nfrom httpx_oauth.oauth2 import OAuth2\n\nclient = OAuth2(\"CLIENT_ID\", \"CLIENT_SECRET\", \"AUTHORIZE_ENDPOINT\", \"ACCESS_TOKEN_ENDPOINT\")\noauth2_authorize_callback = OAuth2AuthorizeCallback(client, \"oauth-callback\")\napp = FastAPI()\n\n@app.get(\"/oauth-callback\", name=\"oauth-callback\")\nasync def oauth_callback(access_token_state=Depends(oauth2_authorize_callback)):\n    token, state = access_token_state\n    # Do something useful\n</code></pre>"},{"location":"oauth2/","title":"OAuth2","text":""},{"location":"oauth2/#generic-client","title":"Generic client","text":"<p>A generic OAuth2 class is provided to adapt to any OAuth2-compliant service. You can instantiate it like this:</p> <pre><code>from httpx_oauth.oauth2 import OAuth2\n\nclient = OAuth2(\n    \"CLIENT_ID\",\n    \"CLIENT_SECRET\",\n    \"AUTHORIZE_ENDPOINT\",\n    \"ACCESS_TOKEN_ENDPOINT\",\n    refresh_token_endpoint=\"REFRESH_TOKEN_ENDPOINT\",\n    revoke_token_endpoint=\"REVOKE_TOKEN_ENDPOINT\",\n)\n</code></pre> <p>Note that <code>refresh_token_endpoint</code> and <code>revoke_token_endpoint</code> are optional since not every services propose to refresh and revoke tokens.</p>"},{"location":"oauth2/#available-methods","title":"Available methods","text":""},{"location":"oauth2/#get_authorization_url","title":"<code>get_authorization_url</code>","text":"<p>Returns the authorization URL where you should redirect the user to ask for their approval.</p> <p>Parameters</p> <ul> <li><code>redirect_uri: str</code>: Your callback URI where the user will be redirected after the service prompt.</li> <li><code>state: str = None</code>: Optional string that will be returned back in the callback parameters to allow you to retrieve state information.</li> <li><code>scope: Optional[List[str]] = None</code>: Optional list of scopes to ask for.</li> <li><code>code_challenge: Optional[str] = None</code>: Optional code_challenge in a PKCE context.</li> <li><code>code_challenge_method: Optional[Literal[\"plain\", \"S256\"]] = None</code>: Optional code_challenge_method in a PKCE context.</li> <li><code>extras_params: Optional[Dict[str, Any]] = None</code>: Optional dictionary containing parameters specific to the service.</li> </ul> <p>Example</p> <pre><code>authorization_url = await client.get_authorization_url(\n    \"https://www.tintagel.bt/oauth-callback\", scope=[\"SCOPE1\", \"SCOPE2\", \"SCOPE3\"],\n)\n</code></pre>"},{"location":"oauth2/#get_access_token","title":"<code>get_access_token</code>","text":"<p>Returns an <code>OAuth2Token</code> object for the service given the authorization code passed in the redirection callback.</p> <p>Raises a <code>GetAccessTokenError</code> if an error occurs.</p> <p>Parameters</p> <ul> <li><code>code: str</code>: The authorization code passed in the redirection callback.</li> <li><code>redirect_uri: str</code>: The exact same <code>redirect_uri</code> you passed to the authorization URL.</li> <li><code>code_verifier: Optional[str]</code>: Optional code verifier in a PKCE context.</li> </ul> <p>Example</p> <pre><code>access_token = await client.get_access_token(\"CODE\", \"https://www.tintagel.bt/oauth-callback\")\n</code></pre>"},{"location":"oauth2/#refresh_token","title":"<code>refresh_token</code>","text":"<p>Returns a fresh <code>OAuth2Token</code> object for the service given a refresh token.</p> <p>Raises a <code>RefreshTokenNotSupportedError</code> if no <code>refresh_token_endpoint</code> was provided.</p> <p>Parameters</p> <ul> <li><code>refresh_token: str</code>: A valid refresh token for the service.</li> </ul> <p>Example</p> <pre><code>access_token = await client.refresh_token(\"REFRESH_TOKEN\")\n</code></pre>"},{"location":"oauth2/#revoke_token","title":"<code>revoke_token</code>","text":"<p>Revokes a token.</p> <p>Raises a <code>RevokeTokenNotSupportedError</code> if no <code>revoke_token_endpoint</code> was provided.</p> <p>Parameters</p> <ul> <li><code>token: str</code>: A token or refresh token to revoke.</li> <li><code>token_type_hint: str = None</code>: Optional hint for the service to help it determine if it's a token or refresh token. Usually either <code>token</code> or <code>refresh_token</code>.</li> </ul> <p>Example</p> <pre><code>await client.revoke_token(\"TOKEN\")\n</code></pre>"},{"location":"oauth2/#get_id_email","title":"<code>get_id_email</code>","text":"<p>Returns the id and the email (if available) of the authenticated user from the API provider. It assumes you have asked for the required scopes.</p> <p>Raises a <code>GetIdEmailError</code> if an error occurs.</p> <p>Parameters</p> <ul> <li><code>token: str</code>: A valid access token.</li> </ul> <p>Example</p> <pre><code>user_id, user_email = await client.get_id_email(\"TOKEN\")\n</code></pre>"},{"location":"oauth2/#oauth2token-class","title":"<code>OAuth2Token</code> class","text":"<p>This class is a wrapper around a standard <code>Dict[str, Any]</code> that bears the response of <code>get_access_token</code>. Properties can vary greatly from a service to another but, usually, you can get access token like this:</p> <pre><code>access_token = token[\"access_token\"]\n</code></pre>"},{"location":"oauth2/#is_expired","title":"<code>is_expired</code>","text":"<p>A utility method is provided to quickly determine if the token is still valid or needs to be refreshed.</p> <p>Example</p> <pre><code>if token.is_expired():\n    token = await client.refresh_token(token[\"refresh_token\"])\n    # Save token to DB\n\naccess_token = token[\"access_token\"]\n# Do something useful with this access token\n</code></pre>"},{"location":"oauth2/#provided-clients","title":"Provided clients","text":"<p>We provide several ready-to-use clients for widely used services with configured endpoints and specificites took into account.</p>"},{"location":"oauth2/#openid","title":"OpenID","text":"<p>Generic client for providers following the OpenID Connect protocol. Besides the Client ID and the Client Secret, you'll have to provide the OpenID configuration endpoint, allowing the client to discover the required endpoints automatically. By convention, it's usually served under the path <code>.well-known/openid-configuration</code>.</p> <pre><code>from httpx_oauth.clients.openid import OpenID\n\nclient = OpenID(\"CLIENT_ID\", \"CLIENT_SECRET\", \"https://example.fief.dev/.well-known/openid-configuration\")\n</code></pre> <ul> <li>\u2753 <code>refresh_token</code>: depends if the OpenID provider supports it</li> <li>\u2753 <code>revoke_token</code>: depends if the OpenID provider supports it</li> </ul>"},{"location":"oauth2/#discord","title":"Discord","text":"<pre><code>from httpx_oauth.clients.discord import DiscordOAuth2\n\nclient = DiscordOAuth2(\"CLIENT_ID\", \"CLIENT_SECRET\")\n</code></pre> <ul> <li>\u2705 <code>refresh_token</code></li> <li>\u2705 <code>revoke_token</code></li> </ul> <p>Warning about <code>get_id_email</code></p> <p>Email is optional for Discord accounts, so the email might be <code>None</code>.</p>"},{"location":"oauth2/#facebook","title":"Facebook","text":"<pre><code>from httpx_oauth.clients.facebook import FacebookOAuth2\n\nclient = FacebookOAuth2(\"CLIENT_ID\", \"CLIENT_SECRET\")\n</code></pre> <ul> <li>\u274c <code>refresh_token</code></li> <li>\u274c <code>revoke_token</code></li> </ul>"},{"location":"oauth2/#get_long_lived_access_token","title":"<code>get_long_lived_access_token</code>","text":"<p>Returns an <code>OAuth2Token</code> object with a long-lived access token given a short-lived access token.</p> <p>Raises a <code>GetLongLivedAccessTokenError</code> if an error occurs.</p> <p>Parameters</p> <ul> <li><code>token: str</code>: A short-lived access token given by <code>get_access_token</code>.</li> </ul> <p>Example</p> <pre><code>long_lived_access_token = await client.get_long_lived_access_token(\"TOKEN\")\n</code></pre>"},{"location":"oauth2/#github","title":"GitHub","text":"<pre><code>from httpx_oauth.clients.github import GitHubOAuth2\n\nclient = GitHubOAuth2(\"CLIENT_ID\", \"CLIENT_SECRET\")\n</code></pre> <ul> <li>\u2705 <code>refresh_token</code></li> <li>\u274c <code>revoke_token</code></li> </ul> <p>Tip</p> <p>You should enable Email addresses permission in the Permissions &amp; events section of your GitHub app parameters. You can find it at https://github.com/settings/apps/{YOUR_APP}/permissions.</p> <p>Refresh tokens are not enabled by default</p> <p>Refresh tokens are currently an optional feature you need to enable in your GitHub app parameters. Read more.</p>"},{"location":"oauth2/#google","title":"Google","text":"<pre><code>from httpx_oauth.clients.google import GoogleOAuth2\n\nclient = GoogleOAuth2(\"CLIENT_ID\", \"CLIENT_SECRET\")\n</code></pre> <ul> <li>\u2705 <code>refresh_token</code></li> <li>\u2705 <code>revoke_token</code></li> </ul>"},{"location":"oauth2/#kakao","title":"Kakao","text":"<pre><code>from httpx_oauth.clients.kakao import KakaoOAuth2\n\nclient = KakaoOAuth2(\"CLIENT_ID\", \"CLIENT_SECRET\")\n</code></pre> <ul> <li>\u2705 <code>refresh_token</code></li> <li>\u2705 <code>revoke_token</code></li> </ul>"},{"location":"oauth2/#linkedin","title":"LinkedIn","text":"<pre><code>from httpx_oauth.clients.linkedin import LinkedInOAuth2\n\nclient = LinkedInOAuth2(\"CLIENT_ID\", \"CLIENT_SECRET\")\n</code></pre> <ul> <li>\u2705 <code>refresh_token</code> (only for selected partners)</li> <li>\u274c <code>revoke_token</code></li> </ul>"},{"location":"oauth2/#naver","title":"NAVER","text":"<pre><code>from httpx_oauth.clients.naver import NaverOAuth2\n\nclient = NaverOAuth2(\"CLIENT_ID\", \"CLIENT_SECRET\")\n</code></pre> <ul> <li>\u2705 <code>refresh_token</code></li> <li>\u2705 <code>revoke_token</code></li> </ul>"},{"location":"oauth2/#okta","title":"Okta","text":"<p>Based on the OpenID client. You need to provide the domain of your Okta domain for automatically discovering the required endpoints.</p> <pre><code>from httpx_oauth.clients.okta import OktaOAuth2\n\nclient = OktaOAuth2(\"CLIENT_ID\", \"CLIENT_SECRET\", \"example.okta.com\")\n</code></pre> <ul> <li>\u2705 <code>refresh_token</code></li> <li>\u2705 <code>revoke_token</code></li> </ul>"},{"location":"oauth2/#reddit","title":"Reddit","text":"<pre><code>from httpx_oauth.clients.reddit import RedditOAuth2\n\nclient = RedditOAuth2(\"CLIENT_ID\", \"CLIENT_SECRET\")\n</code></pre> <ul> <li>\u2705 <code>refresh_token</code></li> <li>\u2705 <code>revoke_token</code></li> </ul> <p>Warning about <code>get_id_email</code></p> <p>Reddit API never return email addresses. Thus, e-mail will always be <code>None</code>.</p>"},{"location":"oauth2/#franceconnect","title":"FranceConnect","text":"<pre><code>from httpx_oauth.clients.franceconnect import FranceConnectOAuth2\n\nclient = FranceConnectOAuth2(\"CLIENT_ID\", \"CLIENT_SECRET\")\n</code></pre> <ul> <li>\u274c <code>refresh_token</code></li> <li>\u274c <code>revoke_token</code></li> </ul> <p>Integration server</p> <p>Since you need to go through a heavy validation process before getting your client ID and secret, you can use during development the integration server with demo credentials. You can enable this mode by setting the <code>integration</code> flag to <code>True</code>.</p> <pre><code>from httpx_oauth.clients.franceconnect import FranceConnectOAuth2\n\nclient = FranceConnectOAuth2(\"CLIENT_ID\", \"CLIENT_SECRET\", integration=True)\n</code></pre>"},{"location":"oauth2/#shopify","title":"Shopify","text":"<p>The OAuth2 client for Shopify allows you to authenticate shop owners so your app can make calls to the Shopify Admin API. Besides the Client ID and Secret, you'll need the shop subdomain of the shop you need to access.</p> <pre><code>from httpx_oauth.clients.shopify import ShopifyOAuth2\n\nclient = ShopifyOAuth2(\"CLIENT_ID\", \"CLIENT_SECRET\", \"my-shop\")\n</code></pre> <ul> <li>\u274c <code>refresh_token</code></li> <li>\u274c <code>revoke_token</code></li> </ul> <p><code>get_id_email</code> is based on the <code>Shop</code> resource</p> <p>The implementation of <code>get_id_email</code> calls the Get Shop endpoint of the Shopify Admin API. It means that it'll return you the ID of the shop and the email of the shop owner.</p>"},{"location":"oauth2/#customize-httpx-client","title":"Customize HTTPX client","text":"<p>By default, requests are made using <code>httpx.AsyncClient</code> with default parameters. If you wish to customize settings, like setting timeout or proxies, you can do this by overloading the <code>get_httpx_client</code> method.</p> <pre><code>from typing import AsyncContextManager\n\nimport httpx\nfrom httpx_oauth.oauth2 import OAuth2\n\n\nclass OAuth2CustomTimeout(OAuth2):\n    def get_httpx_client(self) -&gt; AsyncContextManager[httpx.AsyncClient]:\n        return httpx.AsyncClient(timeout=10.0)  # Use a default 10s timeout everywhere.\n\n\nclient = OAuth2CustomTimeout(\n    \"CLIENT_ID\",\n    \"CLIENT_SECRET\",\n    \"AUTHORIZE_ENDPOINT\",\n    \"ACCESS_TOKEN_ENDPOINT\",\n    refresh_token_endpoint=\"REFRESH_TOKEN_ENDPOINT\",\n    revoke_token_endpoint=\"REVOKE_TOKEN_ENDPOINT\",\n)\n</code></pre>"}]}